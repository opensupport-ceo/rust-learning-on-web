

/*
Reference:=> https://rinthel.github.io/rust-lang-book-ko/ch08-02-strings.html

4장에서 스트링에 관한 이야기를 했습니다만, 지금은 좀 더 깊이 살펴보겠습니다. 새로운 러스트인들은 흔히들 
스트링 부분에서 막히는데 이는 세 가지 개념의 조합으로 인한 것입니다: 가능한 에러를 꼭 노출하도록 하는 
러스트의 성향, 많은 프로그래머의 예상보다 더 복잡한 데이터 구조인 스트링, 그리고 UTF-8입니다. 다른 언어들을 
사용하다 왔을 때 이 개념들의 조합이 러스트의 스트링을 어려운 것처럼 보이게 합니다.

스트링이 컬렉션 장에 있는 이유는 스트링이 바이트의 컬렉션 및 이 바이트들을 텍스트로 통역할때 유용한 기능을 제공하는 
몇몇 메소드로 구현되어 있기 때문입니다. 이번 절에서는 생성, 갱신, 값 읽기와 같은 모든 컬렉션 타입이 가지고 있는, 
String에서의 연산에 대해 이야기 해보겠습니다. 또한 String을 다른 컬렉션들과 다르게 만드는 부분, 즉 사람과 컴퓨터가 
String 데이터를 통역하는 방식 간의 차이로 인해 생기는 String 인덱싱의 복잡함을 논의해보겠습니다.



스트링이 뭔가요?
먼저 스트링이라는 용어가 정확히 무엇을 뜻하는 것인지 정의해보겠습니다. 
러스트는 핵심 언어 기능 내에서 딱 한가지 스트링 타입만 제공하는데, 이는 바로 스트링 슬라이스인 str이고, 
이것의 참조자 형태인 &str을 많이 봤죠. 4장에서는 스트링 슬라이스에 대해 얘기했고, 이는 다른 어딘가에 저장된 UTF-8로 
인코딩된 스트링 데이터의 참조자입니다. 예를 들어, 스트링 리터럴은 프로그램의 바이너리 출력물 내에 저장되어 있으며, 
그러므로 스트링 슬라이스입니다.

String 타입은 핵심 언어 기능 내에 구현된 것이 아니고 러스트의 표준 라이브러리를 통해 제공되며, 커질 수 있고, 
가변적이며, 소유권을 갖고 있고, UTF-8로 인코딩된 스트링 타입입니다. 러스트인들이 “스트링”에 대해 이야기할 때, 
그들은 보통 String과 스트링 슬라이스 &str 타입 둘 모두를 이야기한 것이지, 이들 중 하나를 뜻한 것은 아닙니다. 
이번 절은 대부분 String에 관한 것이지만, 두 타입 모두 러스트 표준 라이브러리에서 매우 많이 사용되며 String과 
스트링 슬라이스 모두 UTF-8로 인코딩되어 있습니다.

또한 러스트 표준 라이브러리는 OsString, OsStr, CString, 그리고 CStr과 같은 몇가지 다른 스트링 타입도 제공합니다. 
심지어 어떤 라이브러리 크레이트들은 스트링 데이터를 저장하기 위해 더 많은 옵션을 제공할 수 있습니다. 
*String/ *Str이라는 
작명과 유사하게, 이들은 종종 소유권이 있는 타입과 이를 빌린 변형 타입을 제공하는데, 이는 String/&str과 비슷합니다. 
이러한 스트링 타입들은, 예를 들면 다른 종류의 인코딩이 된 텍스트를 저장하거나 다른 방식으로 메모리에 저장될 수 있습니다. 
여기서는 이러한 다른 스트링 타입은 다루지 않겠습니다; 이것들을 어떻게 쓰고 어떤 경우에 적합한지에 대해 알고 싶다면 
각각의 API 문서를 확인하시기 바랍니다.

*/



fn main() {
    println!("Hello, world!");

    //비어있는 새로운 String 생성하기
    let mut s1 = String::new();


    /*
    스트링에 담아두고 시작할 초기값을 가지고 있을 것입니다. 그런 경우, to_string 메소드를 이용하는데, 
    이는 Display 트레잇이 구현된 어떤 타입이든 사용 가능하며, 스트링 리터럴도 이 트레잇을 구현하고 있습니다. 
    두 가지 예제를 보여주고 있습니다:

    */
    let data = "initial contents";
    let s2 = data.to_string();

    // the method also works on a literal directly:
    let s3 = "initial contents".to_string(); // let s4 = String::from("initial contents");
    

    //스트링에 다양한 언어로 인삿말 저장하기
    let hello = String::from("السلام عليكم");
    let hello = String::from("Dobrý den");
    let hello = String::from("Hello");
    let hello = String::from("שָׁלוֹם");
    let hello = String::from("नमस्ते");
    let hello = String::from("こんにちは");
    let hello = String::from("안녕하세요");
    let hello = String::from("你好");
    let hello = String::from("Olá");
    let hello = String::from("Здравствуйте");
    let hello = String::from("Hola");

    //push_str 메소드를 사용하여 String에 스트링 슬라이스 추가하기
    let mut s = String::from("foo");
    s.push_str("bar");  


    //스트링 슬라이스를 String에 붙인 이후에 스트링 슬라이스를 사용하기
    //만일 push_str 함수가 s2의 소유권을 가져갔다면, 마지막 줄에서 그 값을 출력할 수 없었을 것입니다. 
    //하지만, 이 코드는 우리가 기대했던 대로 작동합니다!
    //
    let mut s1 = String::from("foo");
    let s2 = "bar";
    s1.push_str(&s2);
    println!("s2 is {}", s2);


    //push 메소드는 한 개의 글자를 파라미터로 받아서 String에 추가합니다.
    let mut s = String::from("lo");
    s.push('l');


    //+ 연산자나 format! 매크로를 이용한 접합
    let s1 = String::from("Hello, ");
    let s2 = String::from("world!");
    let s3 = s1 + &s2; // s1은 여기서 이동되어 더이상 쓸 수 없음을 유의하세요
    //위의 코드 실행 결과로서, 스트링 s3는 Hello, world!를 담게 될 것입니다. 
    //s1이 더하기 연산 이후에 더이상 유효하지 않은 이유와 s2의 참조자가 사용되는 
    //이유는 + 연산자를 사용했을 때 호출되는 함수의 시그니처와 맞춰야 하기 때문입니다.
    // + 연산자는 add 메소드를 사용하는데, 이 메소드의 시그니처는 아래처럼 생겼습니다:
    //fn add(self, s: &str) -> String {

    
    //만일 여러 스트링을 접하고자 한다면, +의 동작은 다루기 불편해 집니다.:
    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");
    
    let s = s1 + "-" + &s2 + "-" + &s3;


    //모든 +와 " 문자들과 함께 보면 어떤 결과가 나올지 알기 어렵습니다. 
    //더 복잡한 스트링 조합을 위해서는 format! 매크로를 사용할 수 있습니다:
    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");

    let s = format!("{}-{}-{}", s1, s2, s3);




    //스트링에 인덱싱 문법을 사용하는 시도
    let s1 = String::from("hello");
    let h = s1[0]; //error


    //바이트와 스칼라 값과 문자소 클러스터(Grapheme cluster)! 이런!
    


    //스트링 슬라이싱하기
    //여기서 s는 스트링의 첫 4바이트를 담고 있는 &str가 될 것입니다. 
    //앞서 우리는 이 글자들이 각각 2바이트를 차지한다고 언급했으므로, 이는 s가 “Зд”이 될 것이란 뜻입니다.
    let hello = "Здравствуйте";
    let s = &hello[0..4];
    //만약에 &hello[0..1]라고 했다면 어떻게 될까요? 답은 다음과 같습니다: 
    //러스트는 벡터 내에 유효하지 않은 인덱스에 접근했을 때와 동일한 방식으로 런타임에 패닉을 발생시킬 것입니다.



    //스트링 내에서 반복적으로 실행되는 메소드
    //이 코드는 다음을 출력할 것입니다:
    //    न
    //    म
    //    स
    //    ्
    //    त
    //    े
    //chars를 “नमस्ते”에 대해 호출하면 char타입의 6개의 값으로 나누어 반환하며, 
    //여러분은 각각의 요소에 접근하기 위해 이 결과값에 대해 반복(iterate)할 수 있습니다:
    //
    for c in "नमस्ते".chars() {
        println!("{}", c);
    }


    //bytes 메소드는 가공되지 않은 각각의 바이트를 반환하는데, 여러분의 문제 범위에 따라 적절할 수도 있습니다:
    //이 코드는 이 String을 구성하는 아래처럼 시작되는 18 바이트를 출력합니다:
    //    224
    //    164
    //    168
    //    224
    //    // ... etc
    for b in "नमस्ते".bytes() {
        println!("{}", b);
    }


    //스트링으로부터 문자소 클러스터를 얻는 방법은 복잡해서, 이 기능은 표준 라이브러리를 통해 제공되지 않습니다. 
    //여러분이 원하는 기능이 이것이라면 crates.io에서 사용 가능한 크레이트가 있습니다.

}





